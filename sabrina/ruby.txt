most important concepts and terms

GETS
The method 'gets' (contrary to 'puts') waits for an input.
For example:
input_text = gets.chomp

ARGV
Returns the ARGV-array, which contains the arguments passed to your script, one per element.
For example:
$ ruby argf.rb -v glark.txt
ARGF.argv   #=> ["-v", "glark.txt"]

LOAD_PATH
Array with elements which are names ofdirectories that ruby will search for files to load. Access by the global variable $LOAD_PATH or $:

REQUIRE
You use 'require' or 'load' to bring a library module into your Ruby program.
For example:
require "test/unit"
require "mathn"

READ FILE
f = File.open("test.txt")
text = f.read
f.close

WRITE FILE
File.open("test.txt", "r+") { |f| f.write("new text after f.write") }

EACH AND MAP
'each' simply iterates over the given enumerable, running the block for each value. It discards the return value of the block and simply returns the original object it was called on:
[1, 2, 3].each do |i|
  i + 1
end  # => [1, 2, 3]
'map' sets the current element being iterated over to the return value of the block, and then returns a new object with those changes. So it "maps" each element to a new one using the block given, hence the name "map":
[1, 2, 3].map do |i|
  i + 1
end  # => [2, 3, 4]

CLASS
Classes have names beginning with a capital letter. They act as factories that build objects. An object built by a certain class is called 'an instance of that class'. Typically, calling the new-method on a class results in an instance being created.
For a class to justify its existence, it needs to have two distinct features:
1. State: A class must have some kind of state that defines the attributes of its instances. In the case of a simple rectangle, this could simply be its length and breadth.
2. Behaviour: A class must also do something meaningful. This is achieved by adding methods to the class that interact with its state to give us meaningful results.

BLOCK
A block is a method, that don't have a name (anonymus method). It is a piece of code that can't be stored in a variable and isn't an object. Every block ends with an "end", can start with "begin", "if", "for" etc. The argument list appears between vertical bars.
For example:
countries.each do |c| <- Argument (like a local variable)
 puts "#{c.name} is sad" unless c.happy?
end

HASH
A hash is a collection of key-value pairs. You retrieve or create a new entry in a Hash by referring to its key.
For example:
student_ages = {
"Jack" => 10,
"Jill" => 12,
"Bob" => 14
}

STRINGS
string interpolation: "The number #{a} is less than #{b}"
Any valid block of Ruby code you place inside #{} will be evaluated and inserted at that location.

METHOD
instance-method and class-method
what's special about new and initialize? Wenn ein Objekt mit 'new' erzeugt wird, wird immer zuerst die 'initialize'-Methode aufgerufen, die immer existiert. Wenn ich sie definiere, überschreibe ich damit die vordefinierte (leere) Methode. arguments you supply to new are actually delivered to initialize
return values: Der zuletzt ausgewertete Ausdruck wird zurückgegeben, "return" ist nicht erforderlich.
Wenn ein Methodenname mit einem Fragezeichen endet, liefert die Methode einen booleschen Wert zurück: true oder false.
arguments (default value, splat): Einer Methode können Default-Argumente übergeben werden: xy(arg=3), Variable Argumente -> * zum splat operator:
http://raflabs.com/blogs/silence-is-foo/2010/08/07/ruby-idioms-what-is-the-splatunary-operator-useful-for/
The splat operator is used to handle methods which have a variable parameter list. It works both ways - you can use it to convert arrays to parameter lists as easily as you convert a parameter list to an array.
It is conventional in Ruby to have '?' at the end of the method if that method returns only boolean values. Though it is not mandated by the syntax, this practice is highly recommended as it increases the readability of code.

variable (local, instance)
Instanzvariablen (müssen nicht deklariert werden) sind Variablen eines Objekts, ihr Geltungsbereich ist auf das Objekt begrenzt. 
Lokale Variablen haben nicht den Wert 'nil' vor ihrer Initialisierung, wie globale und Instanzvariablen. Sie existieren nur in der Methode, in der sie definiert werden.

Variables and Objects
Variables are not objects but references (or pointers) to objects which live in the magical ether beyond. References (and, in turn, variables) merely point to objects; they do not hold the actual objects themselves. When you reference a reference, it does not duplicate the object: both references point to the same object. If you want to duplicate the object (i.e. create another copy of the object in another object rather than simply referencing it), you can use the .clone or .dup method on objects which offer it.
the data an object contains is what it is and its methods are what it can do.

Objekte -> Substantive
Methoden -> Verben
Parameter -> Adverbien

Rückgabewerte und Parameterübergabe
if, else, unless (wenn nicht)
<< fügt einem Array ein neues Element hinzu
